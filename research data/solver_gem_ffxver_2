import sympy as sp
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, Optional, List, Dict, Union
from sympy.abc import x, y
import warnings

class FunctionalSquareRootSolver:
    """Functional square root solver based on Composita method with special solutions"""
    
    def __init__(self, max_terms: int = 15):
        self.max_terms = max_terms
        # 特殊方程的特殊解法字典
        self.special_solutions = {
            'x**2 + 2': self._solve_x2_plus_2,
            'x**2': lambda g: (x**sp.sqrt(2), 0),  # 文献中提到的已知解
        }
        
    def _solve_x2_plus_2(self, g: sp.Expr) -> Tuple[Optional[sp.Expr], Optional[sp.Expr]]:
        """特殊解法：f(f(x)) = x² + 2 (根据文献)"""
        try:
            # 文献中的主要近似解形式
            sqrt2 = sp.sqrt(2)
            f1 = (x**2 + 2)**(sqrt2/2)
            
            # 方法一：S₄(x) 形式
            # 根据文献，a₂ = 0.82, a₃ = -0.45, a₄ = -0.55855905560915
            a2 = 0.82
            a3 = -0.45
            a4 = -0.55855905560915
            
            # 构建 S₄(x)
            S4 = f1 - f1**(-1) + a2*f1**(-2) + a3*f1**(-3) + a4*f1**(-4)
            
            # 验证 S₄(S₄(0)) = 2
            S4_at_0 = float(S4.subs(x, 0))
            S4_S4_at_0 = float(S4.subs(x, S4_at_0))
            
            print(f"文献方法：S₄(0) = {S4_at_0:.6f}, S₄(S₄(0)) = {S4_S4_at_0:.6f} (目标值: 2.0)")
            
            # 返回近似解
            return sp.simplify(S4), None
            
        except Exception as e:
            warnings.warn(f"特殊解法失败: {e}")
            return None, None
    
    def check_special_solution(self, g: sp.Expr) -> bool:
        """检查是否可以使用特殊解法"""
        try:
            g_simplified = sp.simplify(g)
            
            # 检查是否为 x² + 2
            if g_simplified.equals(x**2 + 2):
                return True
                
            # 检查是否为 c*x^a 形式
            if g_simplified.is_polynomial():
                poly = sp.Poly(g_simplified, x)
                if poly.degree() == 2 and poly.coeff_monomial(x**2) == 1 and poly.coeff_monomial(x) == 0 and poly.coeff_monomial(1) == 2:
                    return True
                    
            return False
        except:
            return False
    
    def find_fixed_points(self, g: sp.Expr) -> List[sp.Expr]:
        """Find fixed points of g(x): g(α)=α"""
        equation = sp.simplify(g - x)
        try:
            fixed_points = sp.solve(equation, x, dict=True)
            points = []
            for sol in fixed_points:
                if x in sol:
                    points.append(sol[x])
            return points
        except:
            return []
    
    def shift_to_origin(self, g: sp.Expr, alpha: sp.Expr) -> Tuple[sp.Expr, sp.Symbol]:
        """Shift function to origin: G(y) = g(y+α) - α"""
        y_sym = sp.Symbol('y')
        G = sp.simplify(g.subs(x, y_sym + alpha) - alpha)
        return G, y_sym
    
    def get_taylor_coeffs(self, expr: sp.Expr, var: sp.Symbol, n_terms: int) -> List[sp.Expr]:
        """Get Taylor series coefficients [f(0), f(1), ..., f(n)]"""
        series_expr = sp.series(expr, var, 0, n_terms + 1).removeO()
        
        coeffs = [0] * (n_terms + 1)
        poly = sp.Poly(series_expr, var)
        
        # 获取常数项
        coeffs[0] = poly.coeff_monomial(1) if poly.has(1) else 0
        
        for i in range(1, n_terms + 1):
            coeffs[i] = poly.coeff_monomial(var**i) if poly.has(var**i) else 0
        
        return coeffs
    
    def compute_F_delta(self, f_coeffs: List[sp.Expr], N: int) -> List[List[sp.Expr]]:
        """
        Compute composita F^Δ(n,k)
        Recurrence: F^Δ(n,k) = Σ_{i=1}^{n-k+1} f(i) * F^Δ(n-i, k-1)
        """
        F_delta = [[0] * (N + 1) for _ in range(N + 1)]
        
        for n in range(1, N + 1):
            F_delta[n][1] = f_coeffs[n] if n < len(f_coeffs) else 0
        
        for k in range(2, N + 1):
            for n in range(k, N + 1):
                total = 0
                for i in range(1, n - k + 2):
                    total += f_coeffs[i] * F_delta[n - i][k - 1]
                F_delta[n][k] = sp.simplify(total)
        
        return F_delta
    
    def compute_A_delta(self, F_delta: List[List[sp.Expr]], f1: sp.Expr, N: int) -> List[List[sp.Expr]]:
        """
        Compute composita A^Δ(n,k) for A(A(x)) = F(x)
        Recurrence: A^Δ(n,k) = [F^Δ(n,k) - Σ_{m=k+1}^{n-1} A^Δ(n,m)A^Δ(m,k)] / [f(1)^{n/2} + f(1)^{k/2}]
        """
        A_delta = [[0] * (N + 1) for _ in range(N + 1)]
        
        for n in range(1, N + 1):
            # 修复：避免分数指数，使用平方根形式
            if n % 2 == 0:
                A_delta[n][n] = f1 ** (n // 2)
            else:
                A_delta[n][n] = f1 ** (n / 2)
        
        for n in range(1, N + 1):
            for k in range(n - 1, 0, -1):
                total = 0
                for m in range(k + 1, n):
                    total += A_delta[n][m] * A_delta[m][k]
                
                numerator = F_delta[n][k] - total
                
                # 修复分母计算
                if n % 2 == 0 and k % 2 == 0:
                    denominator = f1 ** (n // 2) + f1 ** (k // 2)
                else:
                    denominator = f1 ** (n / 2) + f1 ** (k / 2)
                
                if denominator == 0:
                    # 处理特殊情况：如果分母为0，尝试调整方法
                    warnings.warn(f"Denominator zero for A^Δ({n},{k}), trying alternative approach")
                    # 使用近似值避免除零
                    denominator = sp.Float(1e-10)
                
                A_delta[n][k] = sp.simplify(numerator / denominator)
        
        return A_delta
    
    def solve_functional_root(self, g: sp.Expr, method: str = 'auto', use_special: bool = True) -> Tuple[Optional[sp.Expr], Optional[sp.Expr]]:
        """
        Solve f(f(x)) = g(x)
        
        Args:
            g: target function
            method: 'shift' - fixed point shift, 'direct' - direct method, 'auto' - automatic
            use_special: 是否使用特殊解法
        
        Returns:
            (f(x), alpha): solution and fixed point used
        """
        # 首先检查是否可以使用特殊解法
        if use_special and self.check_special_solution(g):
            print("检测到特殊方程，尝试使用文献中的解法...")
            result = self._solve_x2_plus_2(g)
            if result[0] is not None:
                return result
        
        if method == 'auto':
            fixed_points = self.find_fixed_points(g)
            if fixed_points:
                method = 'shift'
            else:
                method = 'direct'
        
        if method == 'shift':
            fixed_points = self.find_fixed_points(g)
            if not fixed_points:
                warnings.warn("No fixed points found, trying direct method")
                return self._solve_direct(g), None
            
            alpha = fixed_points[0]
            G, y_sym = self.shift_to_origin(g, alpha)
            
            if G.subs(y_sym, 0) != 0:
                warnings.warn(f"G(0) = {G.subs(y_sym, 0)} ≠ 0, results may be inaccurate")
            
            f_coeffs = self.get_taylor_coeffs(G, y_sym, self.max_terms)
            f1 = f_coeffs[1]
            
            if f1 == 0:
                raise ValueError("f(1)=0, Composita method not applicable")
            
            F_delta = self.compute_F_delta(f_coeffs, self.max_terms)
            A_delta = self.compute_A_delta(F_delta, f1, self.max_terms)
            
            H = 0
            for n in range(1, self.max_terms + 1):
                H += A_delta[n][1] * y_sym**n
            
            f_x = H.subs(y_sym, x - alpha) + alpha
            return sp.simplify(f_x), alpha
        
        else:
            return self._solve_direct(g), None
    
    def _solve_direct(self, g: sp.Expr) -> Optional[sp.Expr]:
        """Direct method: assume g(0)=0"""
        if g.subs(x, 0) != 0:
            warnings.warn(f"g(0) = {g.subs(x, 0)} ≠ 0, direct method may not work")
        
        f_coeffs = self.get_taylor_coeffs(g, x, self.max_terms)
        f1 = f_coeffs[1]
        
        if f1 == 0:
            raise ValueError("f(1)=0, Composita method not applicable")
        
        F_delta = self.compute_F_delta(f_coeffs, self.max_terms)
        A_delta = self.compute_A_delta(F_delta, f1, self.max_terms)
        
        f_x = 0
        for n in range(1, self.max_terms + 1):
            f_x += A_delta[n][1] * x**n
        
        return sp.simplify(f_x)
    
    def verify_solution(self, f: sp.Expr, g: sp.Expr, x_range: Tuple[float, float] = (-0.5, 0.5),
                       n_points: int = 100) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Verify solution: compute f(f(x)) - g(x) and plot"""
        f_num = sp.lambdify(x, f, 'numpy')
        g_num = sp.lambdify(x, g, 'numpy')
        
        x_vals = np.linspace(x_range[0], x_range[1], n_points)
        
        ff_vals = []
        for x_val in x_vals:
            try:
                f_val = float(f_num(x_val))
                ff_val = float(f_num(f_val))
                ff_vals.append(ff_val)
            except Exception as e:
                ff_vals.append(np.nan)
        ff_vals = np.array(ff_vals)
        
        g_vals = g_num(x_vals)
        error_vals = ff_vals - g_vals
        
        fig, axes = plt.subplots(2, 2, figsize=(12, 8))
        
        # 修复：处理可能的复数结果
        g_vals_real = np.real(g_vals)
        f_vals = []
        for x_val in x_vals:
            try:
                f_vals.append(float(f_num(x_val)))
            except:
                f_vals.append(np.nan)
        f_vals = np.array(f_vals)
        
        axes[0, 0].plot(x_vals, g_vals_real, 'b-', label='g(x)', linewidth=2)
        axes[0, 0].plot(x_vals, f_vals, 'r--', label='f(x)', linewidth=2)
        axes[0, 0].set_xlabel('x')
        axes[0, 0].set_ylabel('y')
        axes[0, 0].set_title('Original function and its square root')
        axes[0, 0].legend()
        axes[0, 0].grid(True, alpha=0.3)
        
        axes[0, 1].plot(x_vals, ff_vals, 'g-', label='f(f(x))', linewidth=2)
        axes[0, 1].plot(x_vals, g_vals_real, 'b--', label='g(x)', linewidth=2)
        axes[0, 1].set_xlabel('x')
        axes[0, 1].set_ylabel('y')
        axes[0, 1].set_title('Comparison: f(f(x)) vs g(x)')
        axes[0, 1].legend()
        axes[0, 1].grid(True, alpha=0.3)
        
        axes[1, 0].plot(x_vals, error_vals, 'r-', linewidth=2)
        axes[1, 0].axhline(y=0, color='k', linestyle='--', alpha=0.5)
        axes[1, 0].set_xlabel('x')
        axes[1, 0].set_ylabel('Error')
        axes[1, 0].set_title('Error: f(f(x)) - g(x)')
        axes[1, 0].grid(True, alpha=0.3)
        
        abs_error = np.abs(error_vals)
        valid_idx = ~np.isnan(abs_error) & (abs_error > 0)
        if np.any(valid_idx):
            axes[1, 1].semilogy(x_vals[valid_idx], abs_error[valid_idx], 'm-', linewidth=2)
            axes[1, 1].set_xlabel('x')
            axes[1, 1].set_ylabel('Absolute Error (log scale)')
            axes[1, 1].set_title('Absolute Error (log scale)')
            axes[1, 1].grid(True, alpha=0.3)
        else:
            axes[1, 1].text(0.5, 0.5, 'No valid error data', ha='center', va='center')
        
        plt.tight_layout()
        plt.show()
        
        return x_vals, ff_vals, error_vals
    
    def to_tex_series(self, expr: sp.Expr, n_terms: int = 8) -> str:
        """Convert expression to LaTeX series form"""
        try:
            series_expr = sp.series(expr, x, 0, n_terms + 1).removeO()
            
            terms = []
            for i in range(n_terms + 1):
                coeff = series_expr.coeff(x, i)
                if coeff is not None and coeff != 0:
                    if i == 0:
                        terms.append(f"{sp.latex(coeff)}")
                    elif i == 1:
                        terms.append(f"{sp.latex(coeff)}x")
                    else:
                        terms.append(f"{sp.latex(coeff)}x^{{{i}}}")
            
            if len(terms) == 0:
                return "0"
            elif len(terms) <= 3:
                tex_str = " + ".join(terms)
                tex_str = tex_str.replace("+ -", "- ")
                return tex_str
            else:
                coeffs = self.get_taylor_coeffs(expr, x, min(n_terms, 5))
                tex_str = r"\sum_{n=1}^{" + str(min(n_terms, 5)) + r"} a_n x^n"
                tex_str += r", \quad \text{where} \quad "
                
                coeff_list = []
                for i in range(1, min(len(coeffs), 6)):
                    if coeffs[i] != 0:
                        coeff_list.append(f"a_{{{i}}} = {sp.latex(sp.simplify(coeffs[i]))}")
                
                if coeff_list:
                    tex_str += ", ".join(coeff_list)
                    if len(coeffs) > 6:
                        tex_str += r", \dots"
                else:
                    tex_str = sp.latex(series_expr)
                
                return tex_str
        except:
            # 如果不能展开为级数，直接返回LaTeX形式
            return sp.latex(expr)


def solve_and_plot(g_expr, method='auto', max_terms=10, x_range=(-1, 1), use_special=True):
    """Solve and plot"""
    print("=" * 60)
    print(f"Solve f(f(x)) = {sp.latex(g_expr)}")
    print("=" * 60)
    
    solver = FunctionalSquareRootSolver(max_terms=max_terms)
    
    try:
        f_expr, alpha = solver.solve_functional_root(g_expr, method=method, use_special=use_special)
        
        if f_expr is None:
            print("Cannot solve")
            return None, None
        
        print(f"Fixed point α = {alpha}")
        print(f"\nFunctional square root f(x) = {sp.latex(sp.simplify(f_expr))}")
        print(f"\nLaTeX series form:")
        print(f"$$f(x) = {solver.to_tex_series(f_expr, min(6, max_terms))}$$")
        
        print("\nVerifying solution...")
        x_vals, ff_vals, error_vals = solver.verify_solution(f_expr, g_expr, x_range=x_range)
        
        valid_errors = error_vals[~np.isnan(error_vals)]
        if len(valid_errors) > 0:
            max_abs_error = np.max(np.abs(valid_errors))
            print(f"\nMaximum absolute error: {max_abs_error:.6e}")
        
        # 尝试符号验证
        try:
            if max_terms < 10:
                ff_series = sp.series(f_expr.subs(x, f_expr), x, 0, min(8, max_terms*2)).removeO()
                g_series = sp.series(g_expr, x, 0, min(8, max_terms*2)).removeO()
                
                diff = sp.simplify(ff_series - g_series)
                if diff == 0:
                    print("FINE: f(f(x)) equals g(x) in series expansion sense")
                else:
                    diff_trunc = sp.series(diff, x, 0, 6).removeO()
                    if diff_trunc == 0:
                        print("FINE: f(f(x)) equals g(x) up to high order terms")
                    else:
                        print(f"WARNING: Series difference between f(f(x)) and g(x): {sp.latex(sp.simplify(diff_trunc))}")
        except Exception as e:
            print(f"WARNING: Error in symbolic verification: {e}")
        
        return f_expr, alpha
        
    except Exception as e:
        print(f"Error in solving: {e}")
        import traceback
        traceback.print_exc()
        return None, None


if __name__ == "__main__":
    from sympy import exp, sin
    
    # 设置全局的max_terms
    GLOBAL_MAX_TERMS = 30
    
    print("\n" + "="*60)
    print("Example 1: g(x) = x^2 + 2 (文献中的特例)")
    print("="*60)
    g1 = x**2 + 2
    f1, alpha1 = solve_and_plot(g1, method='auto', max_terms=GLOBAL_MAX_TERMS, x_range=(-1, 1), use_special=True)
    
    print("\n" + "="*60)
    print("Example 2: g(x) = x^2 - x + 1")
    print("="*60)
    g2 = x**2 - x + 1
    f2, alpha2 = solve_and_plot(g2, method='shift', max_terms=GLOBAL_MAX_TERMS, x_range=(-0.5, 0.5))
    
    print("\n" + "="*60)
    print("Example 3: g(x) = x^2 + 2x")
    print("="*60)
    g3 = x**2 + 2*x
    f3, alpha3 = solve_and_plot(g3, method='direct', max_terms=GLOBAL_MAX_TERMS, x_range=(-0.5, 0.5))
    
    print("\n" + "="*60)
    print("Example 4: g(x) = e^x - 1")
    print("="*60)
    g4 = exp(x) - 1
    f4, alpha4 = solve_and_plot(g4, method='direct', max_terms=GLOBAL_MAX_TERMS, x_range=(-0.5, 0.5))
    
    print("\n" + "="*60)
    print("Example 5: g(x) = sin(x)")
    print("="*60)
    g5 = sin(x)
    f5, alpha5 = solve_and_plot(g5, method='direct', max_terms=GLOBAL_MAX_TERMS, x_range=(-0.5, 0.5))
    
    print("\n" + "="*60)
    print(f"所有示例完成。全局 max_terms = {GLOBAL_MAX_TERMS}")
    print("="*60)